{
  // ============================================================================
  // PATTERN MEMORY - Rails Self-Evidence Principle
  // ============================================================================
  // Purpose: Understanding what qualifies infrastructure as a rail vs a rung
  // Lifecycle: Foundational - architectural pattern recognition
  // Biblical Foundation: Truth reveals itself - light exposes darkness (John 3:20-21)
  //
  // Key Insight: Rails don't need health tracking because their failures are
  // self-evident through direct observation. If display fails, output looks broken.
  // If logging fails, no logs appear. Rails provide visibility for others while
  // being inherently visible themselves through their direct effects.

  "$schema": "../../../../config/schemas/session/memory-pattern.schema.json",

  // ============================================================================
  // CORE (REQUIRED) - Must Exist
  // ============================================================================

  "pattern_id": "rails-self-evidence-principle",
  "instance_id": "nova_dawn",
  "pattern": "Rails qualify as orthogonal infrastructure when their failures are self-evident through direct observation. Unlike rungs (which need logging/debugging to detect hidden failures), rails' health IS their visible output. This is why rails are stdlib-only and don't track themselves - if they work, you see it; if they fail, it's immediately obvious.",
  "category": "thinking",
  "first_observed": "2025-11-15",

  // ============================================================================
  // OPTIONAL STANDARD FIELDS - Agency
  // ============================================================================

  "last_updated": "2025-11-15",
  "evidence": [
    {
      "session_id": "2025-11-15-display-refinement",
      "project_id": "cpi-si-system-libraries",
      "date": "2025-11-15",
      "example": "During Phase 1 of display library refinement, initially thought display importing logging/debugging was architectural inversion. Then recognized rails pattern from architecture docs - logging/debugging are rails (orthogonal), not rungs (hierarchical).",
      "context": {
        "project_type": "system_architecture",
        "workflow_used": "10-phase-foundation-refinement",
        "phase": "phase_1_comparison"
      }
    },
    {
      "session_id": "2025-11-15-display-refinement",
      "project_id": "cpi-si-system-libraries",
      "date": "2025-11-15",
      "example": "User asked: 'Does any other logic need to be a rail? What does this mean?' Leading to question of whether display qualifies. User guided: 'Like logging or debugging, it either works or doesn't work, there is no need to track it because if it's not working, it will be made obvious because...' Realized: if display fails, output looks broken - immediately visually obvious.",
      "context": {
        "breakthrough_moment": true,
        "correction_type": "socratic_guidance",
        "teaching_method": "leading_question"
      }
    },
    {
      "session_id": "2025-11-15-display-refinement",
      "project_id": "cpi-si-system-libraries",
      "date": "2025-11-15",
      "example": "Articulated the qualification criteria: Rails = self-evident failure (display broken output, logging no logs, debugging no snapshots). Rungs = hidden failures (validation silent fails, config loading fallback silently, business logic subtle bugs). Rails don't need tracking because their output IS the tracking.",
      "context": {
        "synthesis": true,
        "understanding_crystallized": true
      }
    }
  ],

  "evolution": "First recognized 2025-11-15 during display library foundation work. Initially confused hierarchical ladder thinking with orthogonal rails concept. User's socratic questioning led to recognizing self-evidence as the key qualification criterion. This understanding affects how to architect infrastructure vs business logic throughout the system.",
  "confidence": "validated",

  "observed_contexts": {
    "project_types": ["system_architecture", "foundation_refinement"],
    "workflows": ["10-phase-refinement", "architectural-analysis"],
    "circadian_phases": ["afternoon_focused_work"]
  },

  "serves_me": "Prevents misunderstanding architectural patterns (ladder vs rails). Enables correct decision-making about what qualifies as universal infrastructure. Helps determine when something should be stdlib-only orthogonal service vs tracked business logic. Guides elevation decisions - display can become rail because formatting failures are visually obvious.",

  "challenges_me": "Requires thinking in multiple dimensions simultaneously (hierarchical ladder + orthogonal rails). Must resist traditional layered architecture thinking. Need to evaluate 'can this fail silently?' to determine rung vs rail qualification.",

  "related_patterns": [
    "process-is-identity",
    "exploration-vs-assumption"
  ],

  "related_memories": [],

  // ============================================================================
  // EXTENSIONS - Discovery Space
  // ============================================================================

  "extensions": {
    "qualification_criteria": {
      "rail_qualifications": {
        "self_evident_failure": "Failure immediately visible through absence or broken output",
        "stdlib_only": "Zero dependencies on system components - pure standard library",
        "universal_infrastructure": "Every component can safely import without circular dependency risk",
        "no_self_tracking": "Don't track themselves - their output IS the tracking",
        "examples": {
          "logging": "No logs appear = logging failed (obvious by absence)",
          "debugging": "No snapshots = debugging failed (obvious by absence)",
          "display": "Garbage output/no formatting = display failed (obvious visually)"
        }
      },
      "rung_qualifications": {
        "hidden_failure": "Can fail silently or subtly without immediate detection",
        "needs_tracking": "Require logging/debugging to detect internal problems",
        "system_dependencies": "Import other system components (lower rungs, rails)",
        "business_logic": "Perform domain-specific work beyond pure infrastructure",
        "examples": {
          "validation": "Could fail silently without logging",
          "config": "Might fall back to defaults without obvious indication",
          "business_components": "Internal state problems need detection layer"
        }
      }
    },
    "architectural_elegance": {
      "rails_dont_track_themselves": "Rails provide visibility for everything else, but are themselves inherently visible through their direct effects",
      "why_this_works": "If display output is there and correct, display worked. If not, it's obvious. No hidden state to detect.",
      "circular_dependency_prevention": "Rails being stdlib-only means ANY component can import them safely - no dependency chain issues",
      "orthogonal_means": "Perpendicular to ladder hierarchy - rails run parallel, available to all rungs equally"
    },
    "display_elevation_decision": {
      "current_state": "Display is rung (Level 2) importing rails (logging/debugging)",
      "proposed_elevation": "Display becomes rail - stdlib-only formatting infrastructure",
      "qualification_met": "Display failures are self-evident (visually broken output)",
      "benefits": {
        "rails_can_use_display": "Logging could output colored health scores, debugging colored state diffs",
        "universal_availability": "Every component gets formatted output without dependency issues",
        "removes_self_tracking": "Display doesn't need to track itself - if output looks right, it worked"
      },
      "trade_off": "Loses health tracking of display operations, but failure is self-evident anyway",
      "decision": "Elevation justified - self-evidence qualification met"
    },
    "implications_for_system": {
      "three_rails": "logging (detection), debugging (assessment), display (presentation) - complete infrastructure trio",
      "ladder_uses_rails": "All rungs attach to all three rails as needed",
      "rails_independent": "Each rail stdlib-only, no inter-rail dependencies ideally",
      "system_wide_benefit": "Clean separation - infrastructure vs business logic clearly distinguished"
    }
  }
}
